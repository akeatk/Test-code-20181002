/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/fft.js":
/*!********************!*\
  !*** ./lib/fft.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Free FFT and convolution (JavaScript)\n *\n * Copyright (c) 2017 Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/free-small-fft-in-multiple-languages\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n // https://www.nayuki.io/page/free-small-fft-in-multiple-languages\n\n /*\n Forward FFT (wrapper) (in-place): transform(real, imag)\n Inverse FFT (wrapper) (in-place): inverseTransform(real, imag)\n Forward FFT (radix-2) (in-place): transformRadix2(real, imag)\n Forward FFT (Bluestein) (in-place): transformBluestein(real, imag)\n Circular convolution (real): convolveReal(x, y, out)\n Circular convolution (complex): convolveComplex(xreal, ximag, yreal, yimag, outreal, outimag)\n */\n\n\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function.\n */\nfunction transform(real, imag) {\n\tvar n = real.length;\n\tif (n != imag.length)\n\t\tthrow \"Mismatched lengths\";\n\tif (n == 0)\n\t\treturn;\n\telse if ((n & (n - 1)) == 0)  // Is power of 2\n\t\ttransformRadix2(real, imag);\n\telse  // More complicated algorithm for arbitrary sizes\n\t\ttransformBluestein(real, imag);\n}\n\n\n/*\n * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.\n */\nfunction inverseTransform(real, imag) {\n\ttransform(imag, real);\n}\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector's length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n nlogn\n */\nfunction transformRadix2(real, imag) {\n\t// Length variables\n\tvar n = real.length;\n\tif (n != imag.length)\n\t\tthrow \"Mismatched lengths\";\n\tif (n == 1)  // Trivial transform\n\t\treturn;\n\tvar levels = -1;\n\tfor (var i = 0; i < 32; i++) {\n\t\tif (1 << i == n)\n\t\t\tlevels = i;  // Equal to log2(n)\n\t}\n\tif (levels == -1)\n\t\tthrow \"Length is not a power of 2\";\n\n\t// Trigonometric tables\n\tvar cosTable = new Array(n / 2);\n\tvar sinTable = new Array(n / 2);\n\tfor (var i = 0; i < n / 2; i++) {\n\t\tcosTable[i] = Math.cos(2 * Math.PI * i / n);\n\t\tsinTable[i] = Math.sin(2 * Math.PI * i / n);\n\t}\n\n\t//----------------------------------------------------------------------------\n\t// n = array length\n\t// Bit-reversed addressing permutation\n\tfor (var i = 0; i < n; i++) {\n\t\tvar j = reverseBits(i, levels);\n\t\tif (j > i) {\n\t\t\tvar temp = real[i];\n\t\t\treal[i] = real[j];\n\t\t\treal[j] = temp;\n\t\t\ttemp = imag[i];\n\t\t\timag[i] = imag[j];\n\t\t\timag[j] = temp;\n\t\t}\n\t}\n\t//n\n\n\t// Cooley-Tukey decimation-in-time radix-2 FFT\n\tfor (var size = 2; size <= n; size *= 2) {\n\t\tvar halfsize = size / 2;\n\t\tvar tablestep = n / size;\n\t\tfor (var i = 0; i < n; i += size) {\n\t\t\tfor (var j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\n\t\t\t\tvar l = j + halfsize;\n\t\t\t\tvar tpre =  real[l] * cosTable[k] + imag[l] * sinTable[k];\n\t\t\t\tvar tpim = -real[l] * sinTable[k] + imag[l] * cosTable[k];\n\t\t\t\treal[l] = real[j] - tpre;\n\t\t\t\timag[l] = imag[j] - tpim;\n\t\t\t\treal[j] += tpre;\n\t\t\t\timag[j] += tpim;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n\tfunction reverseBits(x, bits) {\n\t\tvar y = 0;\n\t\tfor (var i = 0; i < bits; i++) {\n\t\t\ty = (y << 1) | (x & 1);\n\t\t\tx >>>= 1;\n\t\t}\n\t\treturn y;\n\t}\n}\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This requires the convolution function, which in turn requires the radix-2 FFT function.\n * Uses Bluestein's chirp z-transform algorithm.\n nlogn but several times slower\n */\nfunction transformBluestein(real, imag) {\n\t// Find a power-of-2 convolution length m such that m >= n * 2 + 1\n\tvar n = real.length;\n\tif (n != imag.length)\n\t\tthrow \"Mismatched lengths\";\n\tvar m = 1;\n\twhile (m < n * 2 + 1)\n\t\tm *= 2;\n\n\t// Trignometric tables\n\tvar cosTable = new Array(n);\n\tvar sinTable = new Array(n);\n\tfor (var i = 0; i < n; i++) {\n\t\tvar j = i * i % (n * 2);  // This is more accurate than j = i * i\n\t\tcosTable[i] = Math.cos(Math.PI * j / n);\n\t\tsinTable[i] = Math.sin(Math.PI * j / n);\n\t}\n\n\t// Temporary vectors and preprocessing\n\tvar areal = newArrayOfZeros(m);\n\tvar aimag = newArrayOfZeros(m);\n\tfor (var i = 0; i < n; i++) {\n\t\tareal[i] =  real[i] * cosTable[i] + imag[i] * sinTable[i];\n\t\taimag[i] = -real[i] * sinTable[i] + imag[i] * cosTable[i];\n\t}\n\tvar breal = newArrayOfZeros(m);\n\tvar bimag = newArrayOfZeros(m);\n\tbreal[0] = cosTable[0];\n\tbimag[0] = sinTable[0];\n\tfor (var i = 1; i < n; i++) {\n\t\tbreal[i] = breal[m - i] = cosTable[i];\n\t\tbimag[i] = bimag[m - i] = sinTable[i];\n\t}\n\n\t// Convolution\n\tvar creal = new Array(m);\n\tvar cimag = new Array(m);\n\tconvolveComplex(areal, aimag, breal, bimag, creal, cimag);\n\n\t// Postprocessing\n\tfor (var i = 0; i < n; i++) {\n\t\treal[i] =  creal[i] * cosTable[i] + cimag[i] * sinTable[i];\n\t\timag[i] = -creal[i] * sinTable[i] + cimag[i] * cosTable[i];\n\t}\n}\n\n\n/*\n * Computes the circular convolution of the given real vectors. Each vector's length must be the same.\n */\nfunction convolveReal(x, y, out) {\n\tvar n = x.length;\n\tif (n != y.length || n != out.length)\n\t\tthrow \"Mismatched lengths\";\n\tconvolveComplex(x, newArrayOfZeros(n), y, newArrayOfZeros(n), out, newArrayOfZeros(n));\n}\n\n\n/*\n * Computes the circular convolution of the given complex vectors. Each vector's length must be the same.\n */\nfunction convolveComplex(xreal, ximag, yreal, yimag, outreal, outimag) {\n\tvar n = xreal.length;\n\tif (n != ximag.length || n != yreal.length || n != yimag.length\n\t\t\t|| n != outreal.length || n != outimag.length)\n\t\tthrow \"Mismatched lengths\";\n\n\txreal = xreal.slice();\n\tximag = ximag.slice();\n\tyreal = yreal.slice();\n\tyimag = yimag.slice();\n\ttransform(xreal, ximag);\n\ttransform(yreal, yimag);\n\n\tfor (var i = 0; i < n; i++) {\n\t\tvar temp = xreal[i] * yreal[i] - ximag[i] * yimag[i];\n\t\tximag[i] = ximag[i] * yreal[i] + xreal[i] * yimag[i];\n\t\txreal[i] = temp;\n\t}\n\tinverseTransform(xreal, ximag);\n\n\tfor (var i = 0; i < n; i++) {  // Scaling (because this FFT implementation omits it)\n\t\toutreal[i] = xreal[i] / n;\n\t\toutimag[i] = ximag[i] / n;\n\t}\n}\n\n\nfunction newArrayOfZeros(n) {\n\tvar result = [];\n\tfor (var i = 0; i < n; i++)\n\t\tresult.push(0);\n\treturn result;\n}\n\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n\n// https://thebreakfastpost.com/2015/10/18/ffts-in-javascript/\n\n//nayuki-obk\n//supposedly better than base functions\n/*\n * Free FFT and convolution (JavaScript)\n *\n * Copyright (c) 2014 Project Nayuki\n * http://www.nayuki.io/page/free-small-fft-in-multiple-languages\n *\n * (MIT License)\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n *\n * Slightly restructured by Chris Cannam, cannam@all-day-breakfast.com\n */\n\"use strict\";\n/*\n * Construct an object for calculating the discrete Fourier transform (DFT) of size n, where n is a power of 2.\n */\nfunction FFTNayuki(n) {\n\n    this.n = n;\n    this.levels = -1;\n    for (var i = 0; i < 32; i++) {\n        if (1 << i == n) {\n            this.levels = i;  // Equal to log2(n)\n        }\n    }\n    if (this.levels == -1) {\n        throw \"Length is not a power of 2\";\n    }\n    this.cosTable = new Array(n / 2);\n    this.sinTable = new Array(n / 2);\n    for (var i = 0; i < n / 2; i++) {\n        this.cosTable[i] = Math.cos(2 * Math.PI * i / n);\n        this.sinTable[i] = Math.sin(2 * Math.PI * i / n);\n    }\n    /*\n     * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n     * The vector's length must be equal to the size n that was passed to the object constructor, and this must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n     */\n    this.forward = function(real, imag) {\n        var n = this.n;\n\n        // Bit-reversed addressing permutation\n        for (var i = 0; i < n; i++) {\n            var j = reverseBits(i, this.levels);\n            if (j > i) {\n                var temp = real[i];\n                real[i] = real[j];\n                real[j] = temp;\n                temp = imag[i];\n                imag[i] = imag[j];\n                imag[j] = temp;\n            }\n        }\n\n        // Cooley-Tukey decimation-in-time radix-2 FFT\n        for (var size = 2; size <= n; size *= 2) {\n            var halfsize = size / 2;\n            var tablestep = n / size;\n            for (var i = 0; i < n; i += size) {\n                for (var j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\n                    var tpre =  real[j+halfsize] * this.cosTable[k] +\n                                imag[j+halfsize] * this.sinTable[k];\n                    var tpim = -real[j+halfsize] * this.sinTable[k] +\n                                imag[j+halfsize] * this.cosTable[k];\n                    real[j + halfsize] = real[j] - tpre;\n                    imag[j + halfsize] = imag[j] - tpim;\n                    real[j] += tpre;\n                    imag[j] += tpim;\n                }\n            }\n        }\n\n        // Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n        function reverseBits(x, bits) {\n            var y = 0;\n            for (var i = 0; i < bits; i++) {\n                y = (y << 1) | (x & 1);\n                x >>>= 1;\n            }\n            return y;\n        }\n    }\n    /*\n     * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.\n     * The vector's length must be equal to the size n that was passed to the object constructor, and this must be a power of 2. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.\n     */\n    this.inverse = function(real, imag) {\n        forward(imag, real);\n    }\n}\n\nmodule.exports = FFTNayuki;\n\n\n//# sourceURL=webpack:///./lib/fft.js?");

/***/ }),

/***/ "./lib/fft_reader.js":
/*!***************************!*\
  !*** ./lib/fft_reader.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("//Cooley-Tukey decimation-in-time radix-2 algorithm\n//nlogn\nclass Turkey{\n  constructor(n){\n    if(Math.log2(n) % 1 > 0)\n      throw \"invalid turkey size\";\n\n    this.levels = Math.log2(n);\n    this.n = n;\n\n    this.cosTable = new Array(n / 2);\n    this.sinTable = new Array(n / 2);\n    for(let i = 0;i < n / 2;i++){\n      this.cosTable[i] = Math.cos(2*Math.PI  * i / n);\n      this.sinTable[i] = Math.sin(2*Math.PI  * i / n);\n    }\n  }\n\n  run(real, imag){\n    let n = this.n;\n\n    for(let i = 0;i < n;i++){\n      const j = this._reverseBits(i, this.levels);\n\n      if(j > i){\n        let temp = real[i];\n  \t\t\treal[i] = real[j];\n  \t\t\treal[j] = temp;\n\n  \t\t\ttemp = imag[i];\n  \t\t\timag[i] = imag[j];\n  \t\t\timag[j] = temp;\n      }\n    }\n\n    for(let size = 2;size <= n;size *= 2){// logn\n      let halfsize = size / 2;\n      let tablestep = n / size;\n      for(let i = 0;i < n;i += size){\n        for(let j = i, k = 0; j < i + halfsize; j++, k+= tablestep){ //\n    \t\t\t\tlet l = j + halfsize;\n    \t\t\t\tlet tpre =  real[l] * this.cosTable[k] + imag[l] * this.sinTable[k];\n    \t\t\t\tlet tpim = -real[l] * this.sinTable[k] + imag[l] * this.cosTable[k];\n\n    \t\t\t\treal[l] = real[j] - tpre;\n    \t\t\t\timag[l] = imag[j] - tpim;\n    \t\t\t\treal[j] += tpre;\n    \t\t\t\timag[j] += tpim;\n        }\n      }\n    }\n\n  }\n\n  reverse(real, imag){\n    this.run(imag, real);\n  }\n\n  _reverseBits(x, bits) {\n    var y = 0;\n    for (var i = 0; i < bits; i++) {\n      y = (y << 1) | (x & 1);\n      x >>>= 1;\n    }\n    return y;\n  }\n}\n\n//Bluestein's chirp z-transform algorithm\n//12n(2 + logn)\n//average = 9nlog(4n)\nclass Zombie{\n  constructor(n){\n    this.n = n;\n    this.m = 1;\n    while(this.m < n * 2 + 1)\n      this.m *= 2;\n\n      console.log(this.m, ' ask;dlfj ', this.n);\n    this.cosTable = new Array(n);\n    this.sinTable = new Array(n);\n    for(let i = 0;i < n;i++){\n      const j = i * i % (n * 2);\n      this.cosTable[i] = Math.cos(Math.PI * j / n);\n      this.sinTable[i] = Math.sin(Math.PI * j / n);\n    }\n\n    this.areal = new Array(this.m);\n    this.aimag = new Array(this.m);\n\n    this.breal = new Array(this.m);\n    this.bimag = new Array(this.m);\n\n    this.creal = new Array(this.m);\n    this.cimag = new Array(this.m);\n\n    this.turkey = new Turkey(this.m);\n  }\n\n  run(real, imag){\n    this._zeroArrays();\n\n  \tfor (var i = 0; i < this.n; i++) {\n  \t\tthis.areal[i] =  real[i] * this.cosTable[i] + imag[i] * this.sinTable[i];\n  \t\tthis.aimag[i] = -real[i] * this.sinTable[i] + imag[i] * this.cosTable[i];\n  \t}\n\n  \tthis.breal[0] = this.cosTable[0];\n  \tthis.bimag[0] = this.sinTable[0];\n  \tfor (var i = 1; i < this.n; i++) {\n  \t\tthis.breal[i] = this.breal[this.m - i] = this.cosTable[i];\n  \t\tthis.bimag[i] = this.bimag[this.m - i] = this.sinTable[i];\n  \t}\n\n    this._convolveComplex();\n\n  \tfor(let i = 0; i < this.m; i++) {\n  \t\treal[i] =  this.creal[i] * this.cosTable[i] + this.cimag[i] * this.sinTable[i];\n  \t\timag[i] = -this.creal[i] * this.sinTable[i] + this.cimag[i] * this.cosTable[i];\n  \t}\n  }\n\n  _convolveComplex(){\n    this.turkey.run(this.areal, this.aimag);\n    this.turkey.run(this.breal, this.bimag);\n\n    for(let i = 0;i < this.m;i++){\n      const temp = this.areal[i] * this.breal[i] - this.aimag[i] * this.bimag[i];\n      this.aimag[i] = this.aimag[i] * this.breal[i] + this.areal[i] * this.bimag[i];\n      this.areal[i] = temp;\n    }\n    this.turkey.reverse(this.areal, this.aimag);\n\n    for(let i = 0;i < this.m;i++){\n      this.creal[i] = this.areal[i] / this.m;\n      this.cimag[i] = this.aimag[i] / this.m;\n    }\n  }\n\n  _zeroArrays(){\n    for(let i = 0;i < this.m;i++)\n      this.areal[i] = this.breal[i] = this.aimag[i] = this.bimag[i] = 0;\n  }\n}\n\nclass FFTReader{\n  constructor(length, type){\n    if(type === 1){//turkey hard-set\n      this.fft = new Turkey(length);\n    }\n    else if(type === 2){//zombie hard-set\n      this.fft = new Zombie(length);\n    }\n    else if(Math.log2(length) % 1 === 0){\n      this.fft = new Turkey(length);\n    }\n    else{\n      this.fft = new Zombie(length);\n    }\n  }\n\n  run(real, imag){\n    this.fft.run(real, imag);\n  }\n\n  receiveData(data){\n    //process fft to freqs, then to notes(?)\n    // freq = samplerate * bucket# / samplesize\n    //samplerate = 44100\n    //samplesize = 2^n\n\n    //4410 === .1 seconds\n    /*\n      input sizes\n      2048\n      4096\n    */\n\n    //32768 ideal bucket size = 1.3458\n      // starting note freq = 23.1246514195 safe = * 2\n    //16384 pref bucket size = 2.691\n      // starting note freq = 46.249302839\n    //8192 is not good bucket size = 5.3833\n      // starting note freq = 92.4986056779\n\n\n    //transfer the exact freq finder using the square root function?\n\n    //figure out a way to account for or use fft spread/spectral leakage\n  }\n}\n\n\nmodule.exports = FFTReader;\n\n\n//# sourceURL=webpack:///./lib/fft_reader.js?");

/***/ }),

/***/ "./lib/main.js":
/*!*********************!*\
  !*** ./lib/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const SoundNodes = __webpack_require__(/*! ./sound_nodes.js */ \"./lib/sound_nodes.js\");\n\nconst FFTReader = __webpack_require__(/*! ./fft_reader.js */ \"./lib/fft_reader.js\");\n\nconst FFTNayuki = __webpack_require__(/*! ./fft.js */ \"./lib/fft.js\");\n\nconst canvas = document.getElementsByTagName(\"canvas\")[0];\nconst ctx = canvas.getContext(\"2d\");\ncanvas.height = 600;\ncanvas.width = 1800;\n\n// read mouse click on canvas\n// function clickCanvas(e) {\n//     const x = e.clientX - canvas.offsetLeft;\n//     const y = e.clientY - canvas.offsetTop;\n//     pond.click(x,y);\n// }\n\n\n\n\n//------------------------------------------------------------------------------\n//try a large fft and only care about increases?\n//double check for correlation between my reader\n\n//tests for fft shifts\n//write a test that draws out the actual line by having dots and shifting\nif(true){\n\n  const len = 512;\n  const turkey = new FFTReader(len);\n\n  const fss = 1/len;\n\n  let r1 = new Array(len);\n  let i1 = new Array(len);\n\n  //create sin wave\n  if(true)\n    for(let i = 0;i < len;i++){\n      r1[i] = 2/8 * Math.sin(5+Math.PI*2*i * (fss * 5))\n          + 2/8*Math.sin(2+Math.PI*2*i * (fss * 6))\n          + 2/8*Math.sin(3+Math.PI*2*i * (fss * 7))\n          + 2/8*Math.sin(6+Math.PI*2*i * (fss * 8))\n          + 2/8*Math.sin(5+Math.PI*2*i * (fss * 9))\n          + 2/8*Math.sin(7+Math.PI*2*i * (fss * 10));\n      i1[i] = 0;\n    }\n  else{}console.log(fss*44100);\n\n  //sound nodes test\n  let sn = new SoundNodes(44100*fss,44100*fss * 20,44100*fss,ctx);\n  sn.sendData(r1);\n  sn.printData();\n\n\n  let r2 = r1.slice();\n  let i2 = i1.slice();\n\n\n  const multi = 300 * 2 / (len * 1.5);\n\n  //20 shifts is surprisingly useful\n  const shifts = 16;\n  canvas.width = len * shifts / 2;\n\n  for(let j = 0;j < shifts;j++){\n    //reset arrays\n    for(let i = 0;i < r2.length;i++){\n      r2[i] = r1[i];\n      i2[i] = 0;\n    }\n\n    //shift\n    const shift_size = fss/shifts * j;\n    for(let i = 0;i < len;i++){\n      i2[i] = r2[i] * Math.cos(Math.PI * 2 * shift_size * i);\n      r2[i] = r2[i] * Math.sin(Math.PI * 2 * shift_size * i);\n    }\n\n    turkey.run(r2,i2);\n\n    //--------------------------------------------------------------------------\n\n    // draw results as line\n    if(false){}\n    else{\n      ctx.fillStyle = '#00f';\n      for(let i = 0;i < r2.length / 2;i++){\n        // value\n        // Math.sqrt(r2[i] * r2[i] + i2[i] * i2[i])\n        ctx.beginPath();\n        ctx.arc(\n          canvas.width/2 + Math.cos(5*Math.log(5+(i + j))) * (10*(i + j) + 50),\n          canvas.height/2 + Math.sin(5*Math.log(5+i + j)) * (10*(i + j) + 50),\n          Math.log(1+Math.sqrt(r2[i] * r2[i] + i2[i] * i2[i])) * 10 ,\n          0,\n          2 * Math.PI\n         );\n        ctx.closePath();\n        ctx.fill();\n      }\n    }\n  }\n}\n\n\n/*\n32k every 4k/2k/1k\n32klog32k = 32k * 15 = 480k\n0 shifts\nstep_size = 2.691650391\nconst_arr_size = 32k\n\n16k = 4k/2k/1k\n16klog16k = 16k * 14 = 224\n1 shift\nstep_size = 5.4 / 2 =  ditto as 32k\n\n\nVVVVVVVVVVVV  This one seems most reasonable for timing, double check intervals\n2k = 2x/1x/1x\n2klog2k = 2k * 11 = 22k\n21.8 => 21/20 shifts\nstep_size = 1.96/2.05\nconst_arr_size = 44k/42k\n\n\n1k = 4x/2x/1x\n1klog1k = 1k * 10 = 10k\n1x = 48 shifts\nstep_size = 1.794\n2x = 24 shifts\n  step_size = 3.589\n4x = 12 shifts\nstep_size = 7.1\n\n\n.5k = 8x/4x/2x\n.5klog.5k = .5k * 9 = 4.5k\n1x 106.7 = 106/105 shifts\nstep_size = 1.61/1.63\nconst_arr_size =53.5k/53k\n2x = 50 shifts\n4x = 26/27 shifts <= this one for now\nstep_size =\n8x = 13 shifts\n\n*/\n\n/*\nwhat is ideal step size for working with cirular freq's with notes?\nrange doubles every 12 notes\n*/\n//visualization test\nif(false){}\n/*\n\nalso, why are steps of 5 special/how can it be made special?\n\n*/\n\n//------------------------------------------------------------------------------\n//FFTS and shifts ARE GOOD\n\n\n//test fftreader (zombie and turkey ffts)\nif(false){}\n\n\n//------------------------------------------------------------------------------\n//test code for\n\nif(false){}\n\n//------------------------------------------------------------------------------\n//test code for sound nodes\n\n//formulas of getting amplitude from 2 slopes\n\n/* key\nα = W = wavelength constant\n  sin(x*w) ; w = 1/(pi * 2) ; wavelength = 1 ; freq = 1\n\nβ = step size\n  44100 per second, so step size = 1/44100\n\nγ = SLOPE 2 (inputed value)\n\nλ = previous slope\n\nσ = slope diff (input - previous slope) || γ - λ\n\nε = slope diff / constants\n  ε = σ / (2*α*sin(-αβ/2))\n*/\n\n/* pre divided 1slope and slope diff formula (input and diff/constants)\n\n*/\n//-----------------------------------\n\nif(false){}\n\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\n//for sound nodes\nif(false){}\n\n\n//------------------------------------------------------------------------------\n//for fft\nif(false){}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\n\nif(false){}\n\n//------------------------------------------------------------------------------\n\n// window.AudioContext = window.AudioContext || window.webkitAudioContext;\n// var context = new AudioContext();\n// var analyser = context.createAnalyser();\n//\n// navigator.webkitGetUserMedia({ audio: true }, function (stream) {\n//     var source = context.createMediaStreamSource(stream);\n//     source.connect(analyser);\n//     analyser.connect(context.destination);\n//\n//     setInterval(function () {\n//         var array = new Uint8Array(analyser.frequencyBinCount);\n//         analyser.getByteFrequencyData(array);\n//         console.log(array);\n//     }, 1000);\n// }, function () { });\n\nif(false){ var Mic, Microphone; }\n\n//------------------------------------------------------------------------------\n\nif(false){ var webaudio_tooling_obj; }\n\n\n//# sourceURL=webpack:///./lib/main.js?");

/***/ }),

/***/ "./lib/sound_nodes.js":
/*!****************************!*\
  !*** ./lib/sound_nodes.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const mic_step_interval = 1/44100;// this is c\n\nclass SoundNodes{\n  constructor(start,end,step_size,ctx){\n    this.ctx = ctx;\n    this.nodes = [];\n    for(let i = start;i <= end;i+=step_size){\n      this.nodes.push(new SoundNode(i, this));\n    }\n\n    //initialize all soundnodes\n    //44100 per second\n\n    this.prev_val = 0;\n    this.prev_slope = 0;\n    console.log('ready');\n  }\n  sendData(array){\n    //given raw sound data and passes it through sound nodes\n    //first run through all data and get a \"volume\"\n    //before passing the data to the nodes, divide the data by the \"volume\"\n    //each node will have a hash with key=slope, value = next val\n    for(let i = 0;i < array.length;i++){\n      const slope = (array[i] - this.prev_val) / mic_step_interval;\n\n      for(let j = 0;j < this.nodes.length;j++){\n        this.nodes[j].sendNext(slope);\n      }\n\n      this.prev_val = array[i];\n      this.prev_slope = slope;\n    }\n  }\n  printData(){\n    console.log(this.nodes.map((node)=>[node.freq,node.value]));\n    let max = -1;\n    for(let i = 0;i < this.nodes.length;i++){\n      if(this.nodes[i].value > max)\n        max = this.nodes[i].value;\n    }\n    max*=1.5;\n    console.log(max);\n    for(let i = 0;i < this.nodes.length;i++){\n      this.ctx.fillStyle='#f00';\n      this.ctx.beginPath();\n      this.ctx.arc(10+i*10, 300 - this.nodes[i].value / max * 300, 5, 0, 2 * Math.PI);\n      this.ctx.closePath();\n      this.ctx.fill();\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n\nclass SoundNode{\n  constructor(freq, parent){\n    this.parent = parent;\n    this.freq = freq;\n\n    //w\n    this.wavelength_const = 2 * Math.PI * freq / 44100;\n\n    //w/2\n    const trig_const = this.wavelength_const / 2;\n\n    const tan = Math.tan(trig_const);\n    const cot = 1 / tan;\n    const csc = 1 / Math.sin(trig_const);\n    const sec = 1 / Math.cos(trig_const);\n\n    this.const1 = Math.pow(tan, 2);\n    this.const2 = Math.pow(cot, 2);\n    this.const3 = 2 * Math.pow(csc, 2);\n    this.const4 = 2 * Math.pow(sec, 2);\n    this.const5 = Math.pow(csc, 2) * Math.pow(sec, 2);\n    this.const6 = 2;\n\n    this.value = 0;\n  }\n\n  sendNext(slope){\n    //wolfram equation\n    // γ-δ=-2αx * sin( (2 * acos(γ/(αx)) - α) / 2) * sin(α/2)\n    //slope = y2\n    //this.parent.prev_slope = previous slope            p  y1\n\n    const prev = this.parent.prev_slope;\n\n    const sum = this.const1 * slope * slope +\n        this.const2 * slope * slope -\n        this.const3 * slope * prev +\n        this.const4 * slope * prev +\n        this.const5 * prev * prev +\n        this.const6 * slope * slope;\n\n    let amplitude;\n    if(sum > 0){\n      amplitude = Math.sqrt(sum) / (2 * this.wavelength_const) * mic_step_interval;\n      if(amplitude){\n        let a = 1 - Math.abs(this.value - amplitude) / this.value;\n        const diff = amplitude - this.value;\n\n        if(a < 0.01)\n          a = 0.01;\n\n        this.value += diff * a;\n      }\n    }\n\n    // const delta = (slope - this.parent.prev_slope) / this.div_const;\n    // if(this.freq === 100)\n    //   console.log(slope,slope-this.parent.prev_slope,this.div_const,delta);\n    //\n    // if(delta <= 1 && delta >= -1){\n    //   const amplitude = slope /\n    //       this.wavelength_const /\n    //       Math.cos(Math.asin(delta) + this.trig_const);\n    //\n    //   if(this.freq === 100)\n    //     console.log(amplitude);\n    //\n    //   //make it vary based on distance from \"val\"\n    //   if(amplitude <= 1)\n    //     this.value += amplitude;\n    // }\n  }\n}\n\n//------------------------------------------------------------------------------\n\nclass VolumeQueue{\n  constructor(length){\n    this.queue = [];\n    this.length = length;\n    this.volume = 1;\n  }\n  add(val){\n    if(this.queue.length === length)\n      this.queue.shift();\n    this.queue.push(val);\n    let sum = 0;\n    for(let i = 0;i < this.queue.length;i++)\n      sum+=this.queue[i];\n    this.volume = sum / this.queue.length;\n    if(this.volume === 0)\n      this.volume = 0.00000001;\n  }\n}\n\nmodule.exports = SoundNodes;\n\n\n//# sourceURL=webpack:///./lib/sound_nodes.js?");

/***/ })

/******/ });