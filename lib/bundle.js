/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/fft.js":
/*!********************!*\
  !*** ./lib/fft.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Free FFT and convolution (JavaScript)\n *\n * Copyright (c) 2017 Project Nayuki. (MIT License)\n * https://www.nayuki.io/page/free-small-fft-in-multiple-languages\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n */\n\n // https://www.nayuki.io/page/free-small-fft-in-multiple-languages\n\n /*\n Forward FFT (wrapper) (in-place): transform(real, imag)\n Inverse FFT (wrapper) (in-place): inverseTransform(real, imag)\n Forward FFT (radix-2) (in-place): transformRadix2(real, imag)\n Forward FFT (Bluestein) (in-place): transformBluestein(real, imag)\n Circular convolution (real): convolveReal(x, y, out)\n Circular convolution (complex): convolveComplex(xreal, ximag, yreal, yimag, outreal, outimag)\n */\n\n\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function.\n */\nfunction transform(real, imag) {\n\tvar n = real.length;\n\tif (n != imag.length)\n\t\tthrow \"Mismatched lengths\";\n\tif (n == 0)\n\t\treturn;\n\telse if ((n & (n - 1)) == 0)  // Is power of 2\n\t\ttransformRadix2(real, imag);\n\telse  // More complicated algorithm for arbitrary sizes\n\t\ttransformBluestein(real, imag);\n}\n\n\n/*\n * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.\n */\nfunction inverseTransform(real, imag) {\n\ttransform(imag, real);\n}\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector's length must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n nlogn\n */\nfunction transformRadix2(real, imag) {\n\t// Length variables\n\tvar n = real.length;\n\tif (n != imag.length)\n\t\tthrow \"Mismatched lengths\";\n\tif (n == 1)  // Trivial transform\n\t\treturn;\n\tvar levels = -1;\n\tfor (var i = 0; i < 32; i++) {\n\t\tif (1 << i == n)\n\t\t\tlevels = i;  // Equal to log2(n)\n\t}\n\tif (levels == -1)\n\t\tthrow \"Length is not a power of 2\";\n\n\t// Trigonometric tables\n\tvar cosTable = new Array(n / 2);\n\tvar sinTable = new Array(n / 2);\n\tfor (var i = 0; i < n / 2; i++) {\n\t\tcosTable[i] = Math.cos(2 * Math.PI * i / n);\n\t\tsinTable[i] = Math.sin(2 * Math.PI * i / n);\n\t}\n\n\t//----------------------------------------------------------------------------\n\t// n = array length\n\t// Bit-reversed addressing permutation\n\tfor (var i = 0; i < n; i++) {\n\t\tvar j = reverseBits(i, levels);\n\t\tif (j > i) {\n\t\t\tvar temp = real[i];\n\t\t\treal[i] = real[j];\n\t\t\treal[j] = temp;\n\t\t\ttemp = imag[i];\n\t\t\timag[i] = imag[j];\n\t\t\timag[j] = temp;\n\t\t}\n\t}\n\t//n\n\n\t// Cooley-Tukey decimation-in-time radix-2 FFT\n\tfor (var size = 2; size <= n; size *= 2) {\n\t\tvar halfsize = size / 2;\n\t\tvar tablestep = n / size;\n\t\tfor (var i = 0; i < n; i += size) {\n\t\t\tfor (var j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\n\t\t\t\tvar l = j + halfsize;\n\t\t\t\tvar tpre =  real[l] * cosTable[k] + imag[l] * sinTable[k];\n\t\t\t\tvar tpim = -real[l] * sinTable[k] + imag[l] * cosTable[k];\n\t\t\t\treal[l] = real[j] - tpre;\n\t\t\t\timag[l] = imag[j] - tpim;\n\t\t\t\treal[j] += tpre;\n\t\t\t\timag[j] += tpim;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n\tfunction reverseBits(x, bits) {\n\t\tvar y = 0;\n\t\tfor (var i = 0; i < bits; i++) {\n\t\t\ty = (y << 1) | (x & 1);\n\t\t\tx >>>= 1;\n\t\t}\n\t\treturn y;\n\t}\n}\n\n\n/*\n * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n * The vector can have any length. This requires the convolution function, which in turn requires the radix-2 FFT function.\n * Uses Bluestein's chirp z-transform algorithm.\n nlogn but several times slower if consisting of multiple composite forms(?)\n */\nfunction transformBluestein(real, imag) {\n\t// Find a power-of-2 convolution length m such that m >= n * 2 + 1\n\tvar n = real.length;\n\tif (n != imag.length)\n\t\tthrow \"Mismatched lengths\";\n\tvar m = 1;\n\twhile (m < n * 2 + 1)\n\t\tm *= 2;\n\n\t// Trignometric tables\n\tvar cosTable = new Array(n);\n\tvar sinTable = new Array(n);\n\tfor (var i = 0; i < n; i++) {\n\t\tvar j = i * i % (n * 2);  // This is more accurate than j = i * i\n\t\tcosTable[i] = Math.cos(Math.PI * j / n);\n\t\tsinTable[i] = Math.sin(Math.PI * j / n);\n\t}\n\n\t// Temporary vectors and preprocessing\n\tvar areal = newArrayOfZeros(m);\n\tvar aimag = newArrayOfZeros(m);\n\tfor (var i = 0; i < n; i++) {\n\t\tareal[i] =  real[i] * cosTable[i] + imag[i] * sinTable[i];\n\t\taimag[i] = -real[i] * sinTable[i] + imag[i] * cosTable[i];\n\t}\n\tvar breal = newArrayOfZeros(m);\n\tvar bimag = newArrayOfZeros(m);\n\tbreal[0] = cosTable[0];\n\tbimag[0] = sinTable[0];\n\tfor (var i = 1; i < n; i++) {\n\t\tbreal[i] = breal[m - i] = cosTable[i];\n\t\tbimag[i] = bimag[m - i] = sinTable[i];\n\t}\n\n\t// Convolution\n\tvar creal = new Array(m);\n\tvar cimag = new Array(m);\n\tconvolveComplex(areal, aimag, breal, bimag, creal, cimag);\n\n\t// Postprocessing\n\tfor (var i = 0; i < n; i++) {\n\t\treal[i] =  creal[i] * cosTable[i] + cimag[i] * sinTable[i];\n\t\timag[i] = -creal[i] * sinTable[i] + cimag[i] * cosTable[i];\n\t}\n}\n\n\n/*\n * Computes the circular convolution of the given real vectors. Each vector's length must be the same.\n */\nfunction convolveReal(x, y, out) {\n\tvar n = x.length;\n\tif (n != y.length || n != out.length)\n\t\tthrow \"Mismatched lengths\";\n\tconvolveComplex(x, newArrayOfZeros(n), y, newArrayOfZeros(n), out, newArrayOfZeros(n));\n}\n\n\n/*\n * Computes the circular convolution of the given complex vectors. Each vector's length must be the same.\n */\nfunction convolveComplex(xreal, ximag, yreal, yimag, outreal, outimag) {\n\tvar n = xreal.length;\n\tif (n != ximag.length || n != yreal.length || n != yimag.length\n\t\t\t|| n != outreal.length || n != outimag.length)\n\t\tthrow \"Mismatched lengths\";\n\n\txreal = xreal.slice();\n\tximag = ximag.slice();\n\tyreal = yreal.slice();\n\tyimag = yimag.slice();\n\ttransform(xreal, ximag);\n\ttransform(yreal, yimag);\n\n\tfor (var i = 0; i < n; i++) {\n\t\tvar temp = xreal[i] * yreal[i] - ximag[i] * yimag[i];\n\t\tximag[i] = ximag[i] * yreal[i] + xreal[i] * yimag[i];\n\t\txreal[i] = temp;\n\t}\n\tinverseTransform(xreal, ximag);\n\n\tfor (var i = 0; i < n; i++) {  // Scaling (because this FFT implementation omits it)\n\t\toutreal[i] = xreal[i] / n;\n\t\toutimag[i] = ximag[i] / n;\n\t}\n}\n\n\nfunction newArrayOfZeros(n) {\n\tvar result = [];\n\tfor (var i = 0; i < n; i++)\n\t\tresult.push(0);\n\treturn result;\n}\n\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n//-----------------------------------------------------------------------------------------------------------------------------------------------\n\n// https://thebreakfastpost.com/2015/10/18/ffts-in-javascript/\n\n//nayuki-obk\n//supposedly better than base functions\n/*\n * Free FFT and convolution (JavaScript)\n *\n * Copyright (c) 2014 Project Nayuki\n * http://www.nayuki.io/page/free-small-fft-in-multiple-languages\n *\n * (MIT License)\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n * - The above copyright notice and this permission notice shall be included in\n *   all copies or substantial portions of the Software.\n * - The Software is provided \"as is\", without warranty of any kind, express or\n *   implied, including but not limited to the warranties of merchantability,\n *   fitness for a particular purpose and noninfringement. In no event shall the\n *   authors or copyright holders be liable for any claim, damages or other\n *   liability, whether in an action of contract, tort or otherwise, arising from,\n *   out of or in connection with the Software or the use or other dealings in the\n *   Software.\n *\n * Slightly restructured by Chris Cannam, cannam@all-day-breakfast.com\n */\n\"use strict\";\n/*\n * Construct an object for calculating the discrete Fourier transform (DFT) of size n, where n is a power of 2.\n */\nfunction FFTNayuki(n) {\n\n    this.n = n;\n    this.levels = -1;\n    for (var i = 0; i < 32; i++) {\n        if (1 << i == n) {\n            this.levels = i;  // Equal to log2(n)\n        }\n    }\n    if (this.levels == -1) {\n        throw \"Length is not a power of 2\";\n    }\n    this.cosTable = new Array(n / 2);\n    this.sinTable = new Array(n / 2);\n    for (var i = 0; i < n / 2; i++) {\n        this.cosTable[i] = Math.cos(2 * Math.PI * i / n);\n        this.sinTable[i] = Math.sin(2 * Math.PI * i / n);\n    }\n    /*\n     * Computes the discrete Fourier transform (DFT) of the given complex vector, storing the result back into the vector.\n     * The vector's length must be equal to the size n that was passed to the object constructor, and this must be a power of 2. Uses the Cooley-Tukey decimation-in-time radix-2 algorithm.\n     */\n    this.forward = function(real, imag) {\n        var n = this.n;\n\n        // Bit-reversed addressing permutation\n        for (var i = 0; i < n; i++) {\n            var j = reverseBits(i, this.levels);\n            if (j > i) {\n                var temp = real[i];\n                real[i] = real[j];\n                real[j] = temp;\n                temp = imag[i];\n                imag[i] = imag[j];\n                imag[j] = temp;\n            }\n        }\n\n        // Cooley-Tukey decimation-in-time radix-2 FFT\n        for (var size = 2; size <= n; size *= 2) {\n            var halfsize = size / 2;\n            var tablestep = n / size;\n            for (var i = 0; i < n; i += size) {\n                for (var j = i, k = 0; j < i + halfsize; j++, k += tablestep) {\n                    var tpre =  real[j+halfsize] * this.cosTable[k] +\n                                imag[j+halfsize] * this.sinTable[k];\n                    var tpim = -real[j+halfsize] * this.sinTable[k] +\n                                imag[j+halfsize] * this.cosTable[k];\n                    real[j + halfsize] = real[j] - tpre;\n                    imag[j + halfsize] = imag[j] - tpim;\n                    real[j] += tpre;\n                    imag[j] += tpim;\n                }\n            }\n        }\n\n        // Returns the integer whose value is the reverse of the lowest 'bits' bits of the integer 'x'.\n        function reverseBits(x, bits) {\n            var y = 0;\n            for (var i = 0; i < bits; i++) {\n                y = (y << 1) | (x & 1);\n                x >>>= 1;\n            }\n            return y;\n        }\n    }\n    /*\n     * Computes the inverse discrete Fourier transform (IDFT) of the given complex vector, storing the result back into the vector.\n     * The vector's length must be equal to the size n that was passed to the object constructor, and this must be a power of 2. This is a wrapper function. This transform does not perform scaling, so the inverse is not a true inverse.\n     */\n    this.inverse = function(real, imag) {\n        forward(imag, real);\n    }\n}\n\nmodule.exports = FFTNayuki;\n\n\n//# sourceURL=webpack:///./lib/fft.js?");

/***/ }),

/***/ "./lib/fft_reader.js":
/*!***************************!*\
  !*** ./lib/fft_reader.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class FFTReader{\n  constructor(length){\n    this.array_length = length;\n\n    this.levels = -1;\n    for (var i = 0; i < 32; i++) {\n        if (1 << i == n) {\n            this.levels = i;  // Equal to log2(n)\n        }\n    }\n    if (this.levels == -1)\n      console.log('fft reader length error for: ', length);\n\n    this.cosTable = new Array(length / 2);\n    this.sinTable = new Array(length / 2);\n    for(let i = 0;i < n / 2;i++){\n      this.cosTable[i] = Math.cos(2 * Math.PI * i / length);\n      this.sinTable[i] = Math.sin(2 * Math.PI * i / length);\n    }\n  }\n  receiveData(data){\n    const length = this.array_length;\n    const reverseBits = (x, bits) => {\n      let y = 0;\n\n      for(let i = 0;i < bits;i++){\n        y = (y << 1) | (x & 1);\n        x >>>= 1;\n      }\n      return y;\n    }\n\n    for (let i = 0; i < length; i++) {\n        const j = reverseBits(i, this.levels);\n\n        if (j > i) {\n            let temp = real[i];\n            real[i] = real[j];\n            real[j] = temp;\n\n            temp = imag[i];\n            imag[i] = imag[j];\n            imag[j] = temp;\n        }\n    }\n\n    //process fft to freqs, then to notes(?)\n    // freq = samplerate * bucket# / samplesize\n    //samplerate = 44100\n    //samplesize = 2^n\n\n    //4410 === .1 seconds\n    /*\n      input sizes\n      2048\n      4096\n    */\n\n    //32768 ideal bucket size = 1.3458\n      // starting note freq = 23.1246514195 safe = * 2\n    //16384 pref bucket size = 2.691\n      // starting note freq = 46.249302839\n    //8192 is not good bucket size = 5.3833\n      // starting note freq = 92.4986056779\n\n\n    //transfer the exact freq finder using the square root function?\n\n    //figure out a way to account for or use fft spread/spectral leakage\n  }\n}\n\n\nmodule.exports = FFTReader;\n\n\n//# sourceURL=webpack:///./lib/fft_reader.js?");

/***/ }),

/***/ "./lib/main.js":
/*!*********************!*\
  !*** ./lib/main.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const SoundNodes = __webpack_require__(/*! ./sound_nodes.js */ \"./lib/sound_nodes.js\");\n\nconst FFTReader = __webpack_require__(/*! ./fft_reader.js */ \"./lib/fft_reader.js\");\n\nconst FFTNayuki = __webpack_require__(/*! ./fft.js */ \"./lib/fft.js\");\n\nconst canvas = document.getElementsByTagName(\"canvas\")[0];\nconst ctx = canvas.getContext(\"2d\");\ncanvas.height = 700;\ncanvas.width = 2100;\n\n// read mouse click on canvas\n// function clickCanvas(e) {\n//     const x = e.clientX - canvas.offsetLeft;\n//     const y = e.clientY - canvas.offsetTop;\n//     pond.click(x,y);\n// }\n\n\n//------------------------------------------------------------------------------\n//test code for\n\nif(true){\n  let dupes = 0;\n  const comfort = Math.pow(2, 15);\n  console.log(comfort);\n  console.log('comfort step = ',44100 / comfort * 2);\n  console.log('comfort time = ',comfort * Math.log2(comfort));\n\n  let arr = [];\n  //write a function to find a bunch of combos and find\n  //the one with lowest avg and lowest max step diff\n\n  //brackets are now array sizes...\n  //test by arrays\n  let brackets = [\n\n  ];\n  const m = Math.pow(2, 1/36);\n  let max = -1;\n  for(let i = 55;i < 110;i *= m){\n    const num = Math.round(44100 / i * 2);\n    if(num > max)\n      max = num;\n    brackets.push(num);\n  }\n\n  console.log('array sizes = ', ...brackets);\n  console.log('max = ', max);\n  max = Math.pow(2, Math.ceil(Math.log2(max)));\n  console.log('intervals = ', max);\n\n\n\n  let time = 0;\n  for(let i = 0; i < brackets.length; i++){\n    time += brackets[i] * Math.log2(brackets[i]) * Math.floor(max / brackets[i]);\n  }\n  console.log('multi-time   = ',time);\n  console.log('comfort time = ',comfort * Math.log2(comfort));\n\n  for(let i = 0;i < brackets.length;i++){\n    const arr_size = brackets[i];\n    const step_size = 44100 / arr_size  * 2;\n\n    let curr = 0;\n\n    for(let j = 1;j < arr_size;j++){\n      const num = j * step_size;\n      while(curr < arr.length && arr[curr] < num){\n        curr++;\n      }\n\n      if(arr[curr] === num || Math.round(arr[curr]) === Math.round(num)){\n        dupes++;\n      }\n      if(arr[curr] !== num){\n        arr.splice(curr,0,num);\n      }\n    }\n    console.log(step_size);\n    console.log(arr.length);\n  }\n\n  //testing vars\n  console.log(...arr.slice(0,100));\n\n  let max1 = 0;\n  let avg1 = 0;\n  let max2 = 0;\n  let avg2 = 0;\n  let c1 = 0;\n  let c2 = 0;\n  for(let i = 0;arr[i] <= 200;i++){\n    const diff = arr[i+1] - arr[i];\n    if(max2 < diff)\n      max2 = diff;\n    avg2 += diff;\n    c2++;\n\n    if(arr[i] <= 100){\n      if(max1 < diff)\n        max1 = diff;\n      avg1 += diff;\n      c1++;\n    }\n  }\n  console.log('max below 100 = ',max1);\n  console.log('avg below 100 = ',avg1/c1);\n  console.log('max below 200 = ',max2);\n  console.log('avg below 200 = ',avg2/c2);\n\n  console.log('dupes = ',dupes);\n  console.log('arr_size = ', arr.length);\n}\n\n//------------------------------------------------------------------------------\n//test code for sound nodes\n\nif(false){}\n\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\n//for sound nodes\nif(false){}\n\n\n//------------------------------------------------------------------------------\n//for fft\nif(false){}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//------------------------------------------------------------------------------\n\nif(false){}\n\n//------------------------------------------------------------------------------\n\n// window.AudioContext = window.AudioContext || window.webkitAudioContext;\n// var context = new AudioContext();\n// var analyser = context.createAnalyser();\n//\n// navigator.webkitGetUserMedia({ audio: true }, function (stream) {\n//     var source = context.createMediaStreamSource(stream);\n//     source.connect(analyser);\n//     analyser.connect(context.destination);\n//\n//     setInterval(function () {\n//         var array = new Uint8Array(analyser.frequencyBinCount);\n//         analyser.getByteFrequencyData(array);\n//         console.log(array);\n//     }, 1000);\n// }, function () { });\n\nif(false){ var Mic, Microphone; }\n\n//------------------------------------------------------------------------------\n\nif(false){ var webaudio_tooling_obj; }\n\n\n//# sourceURL=webpack:///./lib/main.js?");

/***/ }),

/***/ "./lib/sound_nodes.js":
/*!****************************!*\
  !*** ./lib/sound_nodes.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("const mic_step_interval = 1/44100;// this is c\n\nclass SoundNodes{\n  constructor(start,end,step_size,ctx){\n    this.ctx = ctx;\n    this.nodes = [];\n    for(let i = start;i <= end;i+=step_size){\n      this.nodes.push(new SoundNode(i, this));\n    }\n\n    //initialize all soundnodes\n    //44100 per second\n\n    this.prev_val = 0;\n    this.prev_slope = 0;\n    console.log('ready');\n  }\n  sendData(array){\n    //given raw sound data and passes it through sound nodes\n    //first run through all data and get a \"volume\"\n    //before passing the data to the nodes, divide the data by the \"volume\"\n    //each node will have a hash with key=slope, value = next val\n    for(let i = 0;i < array.length;i++){\n      const slope = (array[i] - this.prev_val) / mic_step_interval;\n\n      for(let j = 0;j < this.nodes.length;j++){\n        this.nodes[j].sendNext(slope);\n      }\n\n      this.prev_val = array[i];\n      this.prev_slope = slope;\n    }\n  }\n  printData(){\n    console.log(this.nodes.map((node)=>[node.freq,node.value]));\n    for(let i = 0;i < this.nodes.length;i++){\n      this.ctx.fillStyle='#f0f';\n      this.ctx.beginPath();\n      this.ctx.arc(10+i*10, 10*Math.log(1+500*this.nodes[i].value) + 10, 5, 0, 2 * Math.PI);\n      this.ctx.closePath();\n      this.ctx.fill();\n    }\n  }\n}\n\n//------------------------------------------------------------------------------\n\nclass SoundNode{\n  constructor(freq, parent){\n    this.parent = parent;\n    this.freq = freq;\n\n    //w\n    this.wavelength_const = 2 * Math.PI * freq / 44100;\n\n    //w/2\n    const trig_const = this.wavelength_const / 2;\n\n    const tan = Math.tan(trig_const);\n    const cot = 1 / tan;\n    const csc = 1 / Math.sin(trig_const);\n    const sec = 1 / Math.cos(trig_const);\n\n    this.const1 = Math.pow(tan, 2);\n    this.const2 = Math.pow(cot, 2);\n    this.const3 = 2 * Math.pow(csc, 2);\n    this.const4 = 2 * Math.pow(sec, 2);\n    this.const5 = Math.pow(csc, 2) * Math.pow(sec, 2);\n    this.const6 = 2;\n\n    this.value = 0;\n  }\n\n  sendNext(slope){\n    //wolfram equation\n    // γ-δ=-2αx * sin( (2 * acos(γ/(αx)) - α) / 2) * sin(α/2)\n    //slope = y2\n    //this.parent.prev_slope = previous slope            p  y1\n\n    const prev = this.parent.prev_slope;\n\n    const sum = this.const1 * slope * slope +\n        this.const2 * slope * slope -\n        this.const3 * slope * prev +\n        this.const4 * slope * prev +\n        this.const5 * prev * prev +\n        this.const6 * slope * slope;\n\n    let amp;\n    if(sum > 0){\n      amp = Math.sqrt(sum) / (2 * this.wavelength_const) * mic_step_interval;\n      if(amp){\n        let a = 1 - Math.abs(this.value - amp) / this.value;\n        const diff = amp - this.value;\n\n        if(a < 0.01)\n          a = 0.01;\n\n        this.value += diff * a;\n      }\n    }\n\n    // const delta = (slope - this.parent.prev_slope) / this.div_const;\n    // if(this.freq === 100)\n    //   console.log(slope,slope-this.parent.prev_slope,this.div_const,delta);\n    //\n    // if(delta <= 1 && delta >= -1){\n    //   const amplitude = slope /\n    //       this.wavelength_const /\n    //       Math.cos(Math.asin(delta) + this.trig_const);\n    //\n    //   if(this.freq === 100)\n    //     console.log(amplitude);\n    //\n    //   //make it vary based on distance from \"val\"\n    //   if(amplitude <= 1)\n    //     this.value += amplitude;\n    // }\n  }\n}\n\n//------------------------------------------------------------------------------\n\nclass VolumeQueue{\n  constructor(length){\n    this.queue = [];\n    this.length = length;\n    this.volume = 1;\n  }\n  add(val){\n    if(this.queue.length === length)\n      this.queue.shift();\n    this.queue.push(val);\n    let sum = 0;\n    for(let i = 0;i < this.queue.length;i++)\n      sum+=this.queue[i];\n    this.volume = sum / this.queue.length;\n    if(this.volume === 0)\n      this.volume = 0.00000001;\n  }\n}\n\nmodule.exports = SoundNodes;\n\n\n//# sourceURL=webpack:///./lib/sound_nodes.js?");

/***/ })

/******/ });